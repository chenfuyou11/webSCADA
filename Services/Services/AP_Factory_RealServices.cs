//------------------------------------------------------------------------------
// <auto-generated>
//     此代码已从模板生成。
//
//     手动更改此文件可能导致应用程序出现意外的行为。
//     如果重新生成代码，将覆盖对此文件的手动更改。
// </auto-generated>
//------------------------------------------------------------------------------

namespace Services
{
    using System;
    using System.Collections.Generic;

    using Model;
    using Base;
    using IServices;
    using IRepository;
    using System.Linq;
    using Newtonsoft.Json;
    using Model.ViewObject;

    /// <summary>
    /// 负责每个数据表的业务逻辑操作的约定
    /// </summary>
    public partial class AP_Factory_RealServices : BaseServices<AP_Factory_Real>, IAP_Factory_RealServices
    {
        IAP_Factory_RealRepository dal;
        IAP_Factory_HistoryRepository hisdal;
        #region 定义构造函数，接收autofac将数据仓储层的具体实现类的对象注入到此类中
        public AP_Factory_RealServices(IAP_Factory_RealRepository dal, IAP_Factory_HistoryRepository thisdal)
        {
            this.dal = dal;
            base.baseDal = dal;
            hisdal = thisdal;
        }
        public List<AP_Factory_Real> Test(DateTime currtime,DateTime begtime)
            
        {
            string sql = "select * from AP_Factory_Real";
            return dal.QueryNoParams(sql).ToList();
        }
        #endregion
        #region 大数据界面服务实现方法
        /// <summary>
        /// 大数据界面瞬时流量数据
        /// </summary>
        /// <param name="currtime">当前时间</param>
        /// <param name="begtime">之前时间</param>
        /// <param name="monthtime">月初0点</param>
        /// <returns></returns>
        public object MomentSer(DateTime currtime, DateTime begtime, DateTime monthtime)
        {
            //实时获取的数据
            var res = dal.QueryWhereDesc(f => f.DateTime >= begtime && f.DateTime <= currtime, or => or.OrderByDescending(o => o.DateTime)).FirstOrDefault();
            decimal prof2 = Math.Round(res.ProduceFlowStation.Value / 1000, 2);
            //月流量和
            var Sumres = hisdal.QueryWhere(h => h.DateTime >= monthtime && h.DateTime <= currtime).Sum(s => s.ProduceFlowStation);
            var supply = new
            {
                f1 = res.SumPower,
                f2 = prof2,
                f3 =Math.Round(res.UPI.Value*1000,4),
                f4 = res.PipelinePressure,
                f5 = Sumres / 600/1000  //1000是Nm3转换成KNm3
            };

            return supply;
        }
        /// <summary>
        /// 大数据界面UPI放散率数据
        /// </summary>
        /// <param name="currtime">当前时间</param>
        /// <param name="begtime">之前时间</param>
        /// <returns></returns>
        public object ScatterSer(DateTime currtime, DateTime begtime)
        {
            //取一半
            var res = dal.QueryWhere(f => f.DateTime >= begtime && f.DateTime <= currtime&&f.Id%2==0).Select(s => new
            {
                uPI = s.UPI*1000,//转换单位
                lossRatio = s.LossRatio<0 ?0:s.LossRatio
            }).ToList();
            return res;
        }
        /// <summary>
        /// 大数据界面放散率分布数据
        /// </summary>
        /// <param name="currtime">当前时间</param>
        /// <param name="begtime">之前时间</param>
        /// <param name="jsonList">规定区间</param>
        /// <returns></returns>
        public object FrequencySer(DateTime currtime, DateTime begtime, double[] jsonList)
        {
            var query = dal.QueryWhere(d => d.DateTime >= begtime && d.DateTime <= currtime);
            var res = query.Select(s => new
            {
                loss = s.LossRatio
            }).ToList();
            //最大值 将decimal 换成decimal没有精度损失
            decimal Max = (decimal)res.Max(r => r.loss);
            //最小值
            decimal Min = (decimal)res.Min(r => r.loss);
            if (Min < 0)
            {
                Min = 0;
            }
            //分成10份差值
            decimal Dvalue = (Max - Min) / 10;
            string str = "" + Dvalue;//将间隔便车给字符串
            string[] strarr = str.Split(new char[] { '.' });//将字符串分离成char数组
            int slength = strarr[1].Length;//小数点后位数
            int MinInt = (int)Min;//最小值取整
            int Count = 0;
            List<decimal> douarr = new List<decimal>();//被填充的集合
            for (int i = 0; i < 20; i++)
            {
                decimal listvalue = MinInt + i * Dvalue;
                douarr.Add(listvalue);
                if (listvalue >= Max)
                {
                    Count = i;
                    break;
                }
            }
            int[] arr1 = new int[douarr.Count];//统计出现次数数组
            foreach (var item in res)
            {
                for (int i = 0; i < douarr.Count - 1; i++)
                {
                    if (item.loss >= (decimal)douarr[i] && item.loss < (decimal)douarr[i + 1])
                    {
                        arr1[i]++;
                    }
                    else if (item.loss >= (decimal)douarr[douarr.Count - 1])
                    {
                        arr1[douarr.Count - 1]++;
                    }
                }
            }
            List<decimal> dearr = new List<decimal>();//概率数组
            var sum = arr1.Sum();
            for (int i = 0; i < arr1.Length; i++)
            {
                dearr.Add(Math.Round((decimal)arr1[i] / sum * 100, 2));
            }
            var tranres = new
            {
                xarr = dearr,//概率数组
                xxarr = douarr,//x轴数组
                xdvalue = Dvalue//x轴间隔
            };
            return tranres;
        }
        /// <summary>
        /// 大数据界面压力功率流量数据
        /// </summary>
        /// <param name="currtime">当前时间</param>
        /// <param name="begtime">之前时间</param>
        /// <returns></returns>
        public List<Model.ViewObject.SupplyStackSumpowerpq_VO> SupplyStackSumPowerpq(DateTime currtime, DateTime begtime)
        {
            var res = dal.QueryWhere(f => f.DateTime >= begtime && f.DateTime <= currtime).Select(f => new
            {
                time = f.DateTime,
                mustnum = f.ProduceFlowCentrifuge / 15000,
                runnum = f.RUN_NUM,
                flow = f.ProduceFlowStation,
                press = f.PipelinePressure,
                sumpower = f.SumPower
            }).ToList();
            DateTime StartTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1, 0, 0, 0, 0));
            long timezone = StartTime.Ticks;
            List<Model.ViewObject.SupplyStackSumpowerpq_VO> alllist = new List<Model.ViewObject.SupplyStackSumpowerpq_VO>();
            foreach (var item in res)
            {
                //转换成时间戳到秒
                var trantimezone = (DateTime.Parse("" + item.time).AddHours(8).Ticks - timezone) / 10000;
                Model.ViewObject.SupplyStackSumpowerpq_VO list = new Model.ViewObject.SupplyStackSumpowerpq_VO()
                {
                    //时间戳
                    time = trantimezone,
                    dtime = item.time.ToString(),
                    //必要开启台数
                    Mustnum = Math.Round((decimal)item.mustnum, 2),
                    //实际开机台数
                    Runnum = Convert.ToInt32(item.runnum),
                    //功率
                    Power = Convert.ToInt32(item.sumpower),
                    //流量
                    ProduceStation = Convert.ToInt32(item.flow),
                    //压力
                    Press = (decimal)item.press
                };
                alllist.Add(list);
            }

            return alllist;
        }
        /// <summary>
        /// 必要实际开启台数实时刷新数据
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public Model.ViewObject.SupplyStackSumpowerpq_VO SupplySer(DateTime currtime, DateTime begtime)
        {
            var res = dal.QueryWhereDesc(f => f.DateTime >= begtime && f.DateTime <= currtime,or=>or.OrderByDescending(o=>o.DateTime)).Select(f => new
            {
                time = f.DateTime,
                mustnum =Math.Round((double)f.ProduceFlowCentrifuge / 15000*1.1,1),
                runnum = f.RUN_NUM,
            }).FirstOrDefault();
            DateTime StartTime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1, 0, 0, 0, 0));
            long timezone = StartTime.Ticks;
            var trantimezone = (DateTime.Parse("" + res.time).AddHours(8).Ticks - timezone) / 10000;
            Model.ViewObject.SupplyStackSumpowerpq_VO list = new Model.ViewObject.SupplyStackSumpowerpq_VO()
            {
                time = trantimezone,
                dtime = res.time.ToString(),
                Mustnum = Math.Round((decimal)res.mustnum, 2),
                Runnum = Convert.ToInt32(res.runnum),
            };
            return list;
        }
        /// <summary>
        /// 大数据界面功率流量压力实时刷新数据
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public Model.ViewObject.SupplyStackSumpowerpq_VO StackProEpq(DateTime currtime, DateTime begtime)
        {
            DateTime startTime = TimeZone.CurrentTimeZone.ToLocalTime(new System.DateTime(1970, 1, 1, 0, 0, 0, 0));
            var res = dal.QueryWhereDesc(f => f.DateTime >= begtime && f.DateTime <= currtime,or=>or.OrderByDescending(o=>o.DateTime)).Select(f => new
            {
                time = f.DateTime,
                flow = f.ProduceFlowStation/1000,//单位转换
                press = f.PipelinePressure,
                sumpower = f.SumPower
            }).FirstOrDefault();
            var timezone = startTime.Ticks;
            var trantimezone = (DateTime.Parse("" + res.time).AddHours(8).Ticks - timezone) / 10000;
            Model.ViewObject.SupplyStackSumpowerpq_VO list = new Model.ViewObject.SupplyStackSumpowerpq_VO()
            {
                time = trantimezone,
                Power = Convert.ToInt32(res.sumpower),
                Press = (decimal)res.press,
                ProduceStation = Convert.ToInt32(res.flow)
            };
            return list;
        }
        #endregion

        #region 趋势分析界面服务实现方法
        /// <summary>
        /// 趋势分析界面空压系统工厂的所有数据
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public object TrendFacProducePressSumPower(DateTime currtime, DateTime begtime)
        {
            var starttime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1, 0, 0, 0, 0)).Ticks;
            var query = dal.QueryWhere(d => d.DateTime >= begtime && d.DateTime <= currtime);
            var res = query.ToList().OrderBy(q => q.DateTime).Select(s => new
            {
                time = (DateTime.Parse("" + s.DateTime).AddHours(8).Ticks - starttime) / 10000,
                flow = s.ProduceFlowStation,
                epower = s.SumPower,
                press = s.PipelinePressure,
                upi = s.UPI,
                dre = s.DRE,
                bor = s.LossRatio,
                run = s.RUN_NUM,
                dewp=s.Dewpoint
            }).ToList();
            return res;
        }
        /// <summary>
        /// 趋势分析界面工厂当前时间的数据
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public object TrendFacProducePressSumPowerAjax(DateTime currtime, DateTime begtime)
        {
            var starttime = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1, 0, 0, 0, 0)).Ticks;
            var query = dal.QueryWhere(d => d.DateTime >= begtime && d.DateTime <= currtime);
            var query1 = dal.QueryWhereDesc(d => d.DateTime >= begtime && d.DateTime <= currtime, or => or.OrderByDescending(o => o.DateTime));
            var res = query1.ToList().Select(s => new
            {
                time = (DateTime.Parse("" + s.DateTime).AddHours(8).Ticks - starttime) / 10000,
                flow = s.ProduceFlowStation,
                epower = s.SumPower,
                press = s.PipelinePressure,
                upi = s.UPI,
                dre = s.DRE,
                bor = s.LossRatio,
                run = s.RUN_NUM,
                dewp=s.Dewpoint,
                s.DateTime
            }).FirstOrDefault();
            return res;
        }
        #endregion

        #region 统计分析界面服务实现方法
        /// <summary>
        /// 统计分析，工厂产气量概率分布图/ 小于等于24小时，并且属于今天访问该方法
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <param name="a"></param>
        /// <returns></returns>
        public object Produceflow(DateTime currtime, DateTime begtime, int a)
        {
            int[] testarr = new int[15];
            var query = dal.QueryWhere(d => d.DateTime >= begtime && d.DateTime <= currtime);
            //取一半数据
                query = query.Where(x => x.Id % 2 == 1);
            //获取产气量所有数据
            var res = query.Select(s => new
            {
                p = s.ProduceFlowStation
            }).ToList();
            int Max = (int)res.Max(r => r.p);//最大值
            int Min = (int)res.Min(r => r.p);//最小值
            string MaxStr = (Convert.ToInt32(Max.ToString().Substring(0, 2))).ToString();//最大值的前两位
            string MinStr = (Convert.ToInt32(Min.ToString().Substring(0, 2))).ToString();//最小值的前两位
            //最大值取整
            for (int i = 0; i < Max.ToString().Length - 2; i++)
            {
                MaxStr += "0";
            }
            //最小值取整
            for (int i = 0; i < Min.ToString().Length - 2; i++)
            {
                MinStr += "0";
            }
            int MaxInt = Convert.ToInt32(MaxStr);
            int MinInt = Convert.ToInt32(MinStr);
            int Dvalue = MaxInt - MinInt;//间隔
            int Divide = Dvalue / 10;//分成10份
            int Count = 0;
            for (int i = 0; i < testarr.Length; i++)
            {
                testarr[i] = MinInt + i * Divide;
                if (testarr[i] >= Max)
                {
                    Count = i;
                    break;
                }
            }
            //区间数组的个数
            int Counta = Count + 1;
            int[] arr = new int[Counta];//新的区间数据
            int[] arr1 = new int[Counta];//统计出现次数的数组
            //填充arr
            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = testarr[i];
            }
            for (int i = 0; i < arr.Length - 1; i++)
            {
                foreach (var item in res)
                {
                    if (item.p <= arr[i + 1] && item.p >= arr[i])
                    {
                        arr1[i]++;
                    }
                    else if (item.p > arr[arr.Length - 1])
                    {
                        arr1[arr.Length - 1]++;
                    }
                }
            }
            //概率数组
            decimal[] arr2 = new decimal[arr.Length];
            var bb = arr1.Sum();

            for (int i = 0; i < arr1.Length; i++)
            {
                if (bb != 0)
                {
                    var c = arr1[i];
                    var d = Math.Round((decimal)c / bb * 100, 2);

                    arr2[i] = d;
                }
                else
                {
                    arr2[i] = 0;
                }
            }
            var tranres = new
            {
                a = arr2,//概率数组
                x = arr,//区间数组
                ca = Divide//间隔值
            };
            return tranres;
        }
        /// <summary>
        /// 统计分析，工厂upi和放散率散点，实时表
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public object EScatterSer(DateTime currtime, DateTime begtime)
        {
                var res = dal.QueryWhere(f => f.DateTime >= begtime && f.DateTime <= currtime && f.Id % 2 == 1).Select(s => new {
                    uPI = s.UPI,
                    lossRatio = s.LossRatio<0?0:s.LossRatio
                }).ToList();
                return res;
        }
        /// <summary>
        /// 统计分析，工厂放散率分布图，实时表
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <param name="arr"></param>
        /// <returns></returns>
        public object LossSer(DateTime currtime, DateTime begtime)
        {

            var query = dal.QueryWhere(d => d.DateTime >= begtime && d.DateTime <= currtime);
            query = query.Where(x => x.Id % 2 == 1);
            var res = query.Select(s => new
            {
                loss = s.LossRatio
            }).ToList();
            //最大值 将double 换成decimal没有精度损失
            double Max = (double)res.Max(r => r.loss);
            //最小值
            double Min = (double)res.Min(r => r.loss);
            if (Min < 0)
            {
                Min = 0;
            }
            //分成10份差值
            double Dvalue = (Max - Min) / 10;
            string str = "" + Dvalue;//将间隔便车给字符串
            string[] strarr = str.Split(new char[] { '.' });//将字符串分离成char数组
            int slength = strarr[1].Length;//小数点后位数
            int MinInt = (int)Min;//最小值取整
            int Count = 0;
            List<double> douarr = new List<double>();//被填充的集合
            for (int i = 0; i < 20; i++)
            {
                double listvalue = Math.Round(MinInt + i * Dvalue, slength);
                douarr.Add(listvalue);
                if (listvalue >= Max)
                {
                    Count = i;
                    break;
                }
            }
            int[] arr1 = new int[douarr.Count];//统计出现次数数组
            foreach (var item in res)
            {
                for (int i = 0; i < douarr.Count - 1; i++)
                {
                    if (item.loss >= (decimal)douarr[i] && item.loss < (decimal)douarr[i + 1])
                    {
                        arr1[i]++;
                    }
                    else if (item.loss >= (decimal)douarr[douarr.Count - 1])
                    {
                        arr1[douarr.Count - 1]++;
                    }
                }
            }
            decimal[] dearr = new decimal[arr1.Length];//概率数组
            var sum = arr1.Sum();
            for (int i = 0; i < arr1.Length; i++)
            {
                dearr[i] = Math.Round((decimal)arr1[i] / sum * 100, 2);
            }
            var tranres = new
            {
                a = dearr,
                x = douarr,
                ca = Dvalue,
                l = slength
            };
            return tranres;
        }
        /// <summary>
        /// 统计分析，工厂产气量功率图，实时表
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public object ProduceEpower(DateTime currtime, DateTime begtime)
        {
            var query = dal.QueryWhere(d => d.DateTime >= begtime && d.DateTime <= currtime);
                query = query.Where(x => x.Id % 2 == 1);
            var res = query.Select(s => new
            {
                flow = s.ProduceFlowStation,
                epower = s.SumPower
            }).ToList();
            return res;
        }
        #endregion

        #region 优化指导界面服务实现方法
        /// <summary>
        /// 优化指导，当前实时upi和产气量之和
        /// </summary>
        /// <param name="currtime"></param>
        /// <param name="begtime"></param>
        /// <returns></returns>
        public List<decimal?> EnergyAnalsysUPI(DateTime currtime, DateTime begtime)
        {
            //倒叙12秒查询
            var res = dal.QueryWhereDesc(d => d.DateTime >= begtime && d.DateTime <= currtime,or=>or.OrderByDescending(o=>o.Id)).Select(s => new { s.UPI, s.ProduceFlowCentrifuge,s.RUN_NUM }).FirstOrDefault();
            List<decimal?> deres = new List<decimal?>();
            deres.Add(res.UPI);//当前upi值
            deres.Add(res.ProduceFlowCentrifuge);//各个空压机产气量之和
            deres.Add(res.RUN_NUM);//共启动台数
            return deres;
        }
        #endregion



    }
}
